'''
Defines data models for: songs, playlists
'''
import copy
import datetime
import json

class Song(object):
    '''
    An object representing a song.

    Attrs:
    id: A unique id for the song, generated by the creator
    title: name of the song
    artist: main artist of the song
    album: album in which the song is found
    duration: length of the song in seconds
    '''

    def __init__(self, title, artist, album, duration):
        self.id = None
        self.title = title
        self.artist = artist
        self.album = album
        self.duration = duration

    def __iter__(self):
        return iter((self.id, self.title,
                     self.artist, self.album, self.duration))

    def to_dict(self):
        song = {
            "id": self.id,
            "title": self.title,
            "artist": self.artist,
            "album": self.album,
            "duration": self.duration
        }
        return song

    def get(self):
        return self.to_dict()

    def copy(self):
        return copy.deepcopy(self)

    def s_id(self, s_id=None):
        if s_id is not None:
            self.id = s_id
        return self.id


class Playlist(object):
    '''
    A base object for playlists of different kinds.

    Attrs:
    id: A unique id for the playlist, generated by the creator
    title: Name for the playlist
    descr: Description of the playlist
    creator: Creator of the playlists

    songs: List of songs in the playlists
    song_descr: Dict of descriptions for each song, indexed by id
    '''

    def __init__(self, title, creator, descr=""):
        self.id = None
        self.title = title
        self.creator = creator
        self.songs = list()
        self.song_descr = dict()
        self.size = 0
        self.page = PlaylistPage()
        self.comments = []

        self.metadata = Metadata()
        self.metadata.set_descr(descr)

    def add(self, song, descr=""):
        self.songs.append(song)
        self.song_descr[song.id] = descr
        self.size += 1

    def update_song_descr(self, song, descr):
        self.song_descr[song.id] = descr

    def remove_song(self, song):
        if song in self.songs:
            deleted_song = self.songs.pop(song)
            del self.song_descr[song.id]
            self.size -= 1
            return deleted_song
        else:
            raise ValueError("Song not found")

    def add_comment(self, comment):
        self.comments.append(comment)

    def delete_comment(self, comment_id):
        self.comments.pop(comment_id)

    def s_id(self, p_id=None):
        if p_id is not None:
            self.id = p_id
        return self.id

    def export(self):
        '''
        Returns the playlist as a object to be exported
        '''
        export_obj = {"title": self.title,
                      "creator": self.creator,
                      "description": self.metadata.descr,
                      "songs": [(song.to_dict(), self.song_descr.get(song.id, None)) for song in self.songs]}
        return export_obj

    def copy(self):
        return copy.deepcopy(self)

    def __iter__(self):
        return PlaylistIterator(self)

    def __next__(self):
        pass



class PlaylistIterator:
    '''
    Iterator for playlists
    '''

    def __init__(self, playlist):
        self.playlist = playlist
        self.index = 0

    def __next__(self):
        if self.index < self.playlist.size:
            self.index += 1
            return self.playlist.songs[self.index - 1].get()
        else:
            raise StopIteration()


class PlaylistPage:
    '''
    Stores the settings related to the page that will display the playlist
    '''

    def __init__(self, color=None, commenting=False):
        self.set_color(color) # 7 character hex string: #RRGGBB
        self.set_commenting(commenting)

    def set_commenting(self, commenting):
        self.commenting = commenting

    def set_color(self, color):
        '''
        Computations done according to https://planetcalc.com/7779/
        '''
        if color is not None:
            self.color = color
            C_norm = ((int(color[1:3], 16) / 255),
                      (int(color[3:5], 16) / 255),
                      (int(color[5:7], 16) / 255))
            C_lin = [((c + 0.055) / 1.055)**2.4 if c > 0.03928
                     else c / 12.92 for c in C_norm]
            luminance = 0.2126 * C_lin[0] + 0.7152 * C_lin[1] + 0.0722 * C_lin[2]
            text_luma = (1 / 7) * (luminance - 0.3)
            self.text_color = '#303133' if text_luma > 0.04 else '#ffffff'
            # #303133 is dark with 0.03 luminance
            #Â #ffffff is white with 1 luminance
        else:
            self.color = '#000000'
            self.text_color = '#303133'


class Comment:
    '''
    Helper class that contains a comment, its author, date
    '''

    def __init__(self, content, author, date=None):
        self.content = content
        self.author = author
        if date:
            self.date = date
        else:
            self.date = datetime.datetime.now()

    def s_id(self, c_id):
        self.id = c_id

class Metadata:
    '''
    Helper class that contains some metadata about playlists
    '''

    def __init__(self, descr=None, image=None):
        self.image = image
        self.descr = descr
        self.status = False
        if descr or image:
            self.status = True

    def set_descr(self,content):
        self.descr = content
        self.status = True

    def set_thumbnail(self,img):
        self.thumbnail = img
        self.status = True

class corePlaylist:
    '''
    A compact playlist with only id, title, creator and permission info,
    intended to be used in queries
    '''
    def __init__(self, p_id, title, creator):
        self.id = p_id
        self.title = title
        self.creator = creator
        self.creator_id = 0
